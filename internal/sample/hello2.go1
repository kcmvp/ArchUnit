package main

import (
	"fmt"
	"go/ast"
	"go/types"
	"golang.org/x/tools/go/packages"
)

type ExportedSymbol struct {
	Name string
	Type types.Type
}

func getExportedSymbols(packageName string) ([]ExportedSymbol, error) {
	cfg := &packages.Config{
		Mode: packages.NeedTypes | packages.NeedTypesInfo | packages.NeedFiles | packages.NeedTypesInfo | packages.NeedDeps | packages.NeedImports | packages.NeedSyntax,
		Dir:  "",
	}
	pkgs, _ := packages.Load(cfg, "./...")

	if len(pkgs) == 0 {
		return nil, fmt.Errorf("package '%s' not found", packageName)
	}

	// Access the first package object (assuming a single package)
	pkg := pkgs[0]
	symbols := []ExportedSymbol{}

	// Use the existing Syntax field for AST access
	for _, file := range pkg.Syntax {
		// No need to parse again, use the existing AST
		//fset := token.NewFileSet() // Create a file set for error reporting (optional)

		// Use ast.Inspect on the existing file AST
		ast.Inspect(file, func(n ast.Node) bool {
			switch x := n.(type) {
			case *ast.TypeSpec:
				if x.Name.IsExported() {
					symbols = append(symbols, ExportedSymbol{Name: x.Name.Name, Type: pkg.TypesInfo.Types(x.Type)})
				}
			//case *ast.ValueSpec:
			//	for _, name := range x.Names {
			//		if name.IsExported() {
			//			symbols = append(symbols, ExportedSymbol{Name: name.Name, Type: pkg.Types.Info.TypeOf(name)})
			//		}
			//	}
			//case *ast.FuncDecl:
			//	if x.Name.IsExported() {
			//		symbols = append(symbols, ExportedSymbol{Name: x.Name.Name, Type: pkg.Types.Info.TypeOf(x.Type)})
			//	}
			//}
			return true // Continue inspection
		})
	}

	return symbols, nil
}

func main() {
	packageName := "fmt" // Replace with the desired package name
	exportedSymbols, err := getExportedSymbols(packageName)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	fmt.Println("Exported symbols in", packageName)
	for _, symbol := range exportedSymbols {
		fmt.Printf("%s: %T\n", symbol.Name, symbol.Type)
	}
}
